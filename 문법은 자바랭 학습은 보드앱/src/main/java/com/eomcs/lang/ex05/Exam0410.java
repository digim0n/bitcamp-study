package com.eomcs.lang.ex05;

//# 비트 이동 연산자 : >>, >>>, <<
//
public class Exam0410 {
  public static void main(String[] args) {
    // << 비트 이동 연산자 사용법
    // - 1) 왼쪽으로 비트를 이동시켜
    // - 2)오른 쪽 빈자리는 0으로 채워버려
    // - 3) 왼쪽 경계를 넘어간 비트는 날라버린다 -> 오버플로우라고 하고 제거해버려 한자리면 2 두자리면 4 4자리면 16인거로 보아 2의 1승과 같네
    //
    int i = 1;
    //      [00000000000000000000000000000001] = 1

    System.out.println(i << 1);
    //     0[0000000000000000000000000000001 ]
    //      [00000000000000000000000000000010] = 2

    System.out.println(i << 2);
    //    00[000000000000000000000000000001  ]
    //      [00000000000000000000000000000100] = 4

    System.out.println(i << 3);
    //   000[00000000000000000000000000001   ]
    //      [00000000000000000000000000001000] = 8

    System.out.println(i << 4);
    //  0000[0000000000000000000000000001    ]
    //      [00000000000000000000000000010000] = 16

    i = 11; // [00000000000000000000000000001011]- 요게 i는 11이자나  밑에보면 1,2,3만큼 이동시키고 싶다는데
    System.out.println(i << 1); //   0[00000000000000000000000000010110] => 22 = 요거 보면 11에다가 2의 1배수 곱한거랑 똑같네

    System.out.println(i << 2); //  00[00000000000000000000000000101100] => 44 = 요거 보면 11에다가 2의 2배수 곱한거랑 똑같네

    System.out.println(i << 3); // 000[00000000000000000000000001011000] => 88 =요거 보면 11에다가 2의 3배수 곱한거랑 똑같네

    // 왼쪽 이동
    // - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
    // - 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다
    //   왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
    //   실무에서는 이 비트 이동 연산을 자주 사용한다.
    // - 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.
  }
}





